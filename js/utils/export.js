/**
 * ================================================
 * LANDCRAFT - Export Utilities
 * Code generation and export functions
 * ================================================
 */

const ExportUtils = {
    /**
     * Generate complete HTML code for the landing page
     * @param {Object} state - Application state
     * @returns {string} Complete HTML code
     */
    generateHTML(state) {
        const { projectName, header, steps, settings } = state;
        const css = this.generateCSS(state);
        const js = this.generateJS(state);

        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="${Helpers.sanitizeHTML(header.description?.text || 'Landing Page')}">
    <title>${Helpers.sanitizeHTML(projectName || 'Landing Page')}</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
${css}
    </style>
</head>
<body>
    <div class="landing-page-container">
        ${this.generateHeaderHTML(header)}
        
        <form id="landingPageForm" class="landing-form" novalidate>
            ${settings.showProgressBar && steps.length > 1 ? this.generateProgressBar(steps) : ''}
            
            <div class="form-steps-container">
                ${steps.map((step, index) => this.generateStepHTML(step, index, steps.length)).join('\n')}
            </div>

            ${steps.length > 1 ? this.generateNavigationHTML() : ''}
        </form>

        <div id="successMessage" class="success-message" style="display: none;">
            <div class="success-icon">‚úì</div>
            <h2>Thank You!</h2>
            <p>${Helpers.sanitizeHTML(settings.successMessage || 'Your response has been recorded.')}</p>
        </div>
    </div>

    <script>
${js}
    </script>
</body>
</html>`;
    },

    /**
     * Generate CSS for the landing page
     * @param {Object} state - Application state
     * @returns {string} CSS code
     */
    generateCSS(state) {
        const { header } = state;
        
        return `/* Landing Page Styles - Generated by LandCraft */
:root {
    --primary-color: #6366f1;
    --primary-hover: #4f46e5;
    --text-color: #1e293b;
    --text-secondary: #64748b;
    --bg-color: #f8fafc;
    --card-bg: #ffffff;
    --border-color: #e2e8f0;
    --error-color: #ef4444;
    --success-color: #22c55e;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, sans-serif;
    background-color: var(--bg-color);
    color: var(--text-color);
    line-height: 1.6;
    min-height: 100vh;
}

.landing-page-container {
    max-width: 640px;
    margin: 0 auto;
    padding: 24px 16px;
}

/* Header Styles */
.landing-header {
    text-align: center;
    margin-bottom: 32px;
}

.header-image {
    width: 100%;
    height: ${header.image?.height || 300}px;
    object-fit: cover;
    border-radius: 16px;
    margin-bottom: 24px;
}

.header-title {
    font-family: ${header.title?.fontFamily || 'Plus Jakarta Sans'}, sans-serif;
    font-size: ${header.title?.fontSize || 32}px;
    color: ${header.title?.color || '#1e293b'};
    font-weight: ${header.title?.bold ? '700' : '600'};
    font-style: ${header.title?.italic ? 'italic' : 'normal'};
    text-decoration: ${header.title?.underline ? 'underline' : 'none'};
    text-align: ${header.title?.align || 'center'};
    margin-bottom: 16px;
}

.header-description {
    font-size: ${header.description?.fontSize || 16}px;
    color: ${header.description?.color || '#64748b'};
    line-height: 1.7;
}

/* Form Styles */
.landing-form {
    background: var(--card-bg);
    border-radius: 16px;
    padding: 32px;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.06);
}

/* Progress Bar */
.progress-container {
    margin-bottom: 32px;
}

.progress-steps {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.progress-step {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: var(--border-color);
    transition: all 0.3s ease;
}

.progress-step.active {
    background: var(--primary-color);
    transform: scale(1.2);
}

.progress-step.completed {
    background: var(--success-color);
}

.progress-connector {
    width: 40px;
    height: 2px;
    background: var(--border-color);
    transition: background 0.3s ease;
}

.progress-connector.completed {
    background: var(--success-color);
}

.progress-text {
    text-align: center;
    margin-top: 12px;
    font-size: 14px;
    color: var(--text-secondary);
}

/* Step Styles */
.form-step {
    display: none;
}

.form-step.active {
    display: block;
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.step-title {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 24px;
    padding-bottom: 16px;
    border-bottom: 1px solid var(--border-color);
}

/* Field Styles */
.form-field {
    margin-bottom: 20px;
}

.form-field.hidden {
    display: none;
}

.field-label {
    display: block;
    font-size: 14px;
    font-weight: 500;
    color: var(--text-color);
    margin-bottom: 8px;
}

.required-mark {
    color: var(--error-color);
    margin-left: 2px;
}

.field-input,
.field-select,
.field-textarea {
    width: 100%;
    padding: 12px 16px;
    font-size: 15px;
    border: 1px solid var(--border-color);
    border-radius: 10px;
    background: #fff;
    color: var(--text-color);
    transition: all 0.2s ease;
}

.field-input:focus,
.field-select:focus,
.field-textarea:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
}

.field-input.error,
.field-select.error,
.field-textarea.error {
    border-color: var(--error-color);
}

.field-textarea {
    min-height: 100px;
    resize: vertical;
}

.field-error {
    font-size: 13px;
    color: var(--error-color);
    margin-top: 6px;
    display: none;
}

.field-error.show {
    display: block;
}

/* Radio & Checkbox Styles */
.options-group {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.option-label {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    border: 1px solid var(--border-color);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.option-label:hover {
    border-color: var(--primary-color);
    background: rgba(99, 102, 241, 0.05);
}

.option-label input {
    width: 18px;
    height: 18px;
    accent-color: var(--primary-color);
}

/* File Upload */
.file-upload-wrapper {
    border: 2px dashed var(--border-color);
    border-radius: 12px;
    padding: 32px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.file-upload-wrapper:hover {
    border-color: var(--primary-color);
    background: rgba(99, 102, 241, 0.05);
}

.file-upload-wrapper input {
    display: none;
}

.file-upload-icon {
    font-size: 32px;
    margin-bottom: 8px;
}

.file-upload-text {
    font-size: 14px;
    color: var(--text-secondary);
}

.file-name {
    margin-top: 12px;
    font-size: 13px;
    color: var(--primary-color);
}

/* Navigation Buttons */
.form-navigation {
    display: flex;
    justify-content: space-between;
    margin-top: 32px;
    padding-top: 24px;
    border-top: 1px solid var(--border-color);
}

.btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px 32px;
    font-size: 15px;
    font-weight: 600;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.btn-primary {
    background: var(--primary-color);
    color: white;
}

.btn-primary:hover {
    background: var(--primary-hover);
    transform: translateY(-1px);
}

.btn-secondary {
    background: var(--border-color);
    color: var(--text-color);
}

.btn-secondary:hover {
    background: #d1d5db;
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

/* Success Message */
.success-message {
    text-align: center;
    padding: 48px 32px;
    background: var(--card-bg);
    border-radius: 16px;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.06);
}

.success-icon {
    width: 64px;
    height: 64px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 24px;
    background: rgba(34, 197, 94, 0.1);
    color: var(--success-color);
    font-size: 32px;
    border-radius: 50%;
}

.success-message h2 {
    font-size: 24px;
    margin-bottom: 12px;
}

.success-message p {
    color: var(--text-secondary);
}

/* Responsive */
@media (max-width: 640px) {
    .landing-page-container {
        padding: 16px;
    }
    
    .landing-form {
        padding: 24px 20px;
    }
    
    .header-title {
        font-size: 24px;
    }
    
    .form-navigation {
        flex-direction: column;
        gap: 12px;
    }
    
    .btn {
        width: 100%;
    }
}`;
    },

    /**
     * Generate JavaScript for the landing page
     * @param {Object} state - Application state
     * @returns {string} JavaScript code
     */
    generateJS(state) {
        const { steps, settings } = state;
        const webhookUrl = settings.webhookUrl || '';
        const fieldsConfig = this.generateFieldsConfig(steps);

        return `// Landing Page Form Handler - Generated by LandCraft
(function() {
    'use strict';

    // Configuration
    const config = {
        webhookUrl: '${webhookUrl}',
        totalSteps: ${steps.length},
        fields: ${JSON.stringify(fieldsConfig, null, 8)}
    };

    // State
    let currentStep = 0;
    const formData = {};

    // DOM Elements
    const form = document.getElementById('landingPageForm');
    const steps = document.querySelectorAll('.form-step');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const progressSteps = document.querySelectorAll('.progress-step');
    const progressConnectors = document.querySelectorAll('.progress-connector');
    const progressText = document.getElementById('progressText');
    const successMessage = document.getElementById('successMessage');

    // Initialize
    function init() {
        setupEventListeners();
        updateNavigation();
        updateProgress();
        initConditionalLogic();
    }

    // Event Listeners
    function setupEventListeners() {
        if (prevBtn) prevBtn.addEventListener('click', handlePrev);
        if (nextBtn) nextBtn.addEventListener('click', handleNext);
        
        form.querySelectorAll('input, select, textarea').forEach(input => {
            input.addEventListener('change', handleInputChange);
            input.addEventListener('input', handleInputChange);
        });
    }

    // Handle input changes
    function handleInputChange(e) {
        const field = e.target;
        const fieldId = field.name;
        
        if (field.type === 'checkbox') {
            if (!formData[fieldId]) formData[fieldId] = [];
            if (field.checked) {
                if (!formData[fieldId].includes(field.value)) {
                    formData[fieldId].push(field.value);
                }
            } else {
                formData[fieldId] = formData[fieldId].filter(v => v !== field.value);
            }
        } else if (field.type === 'file') {
            formData[fieldId] = field.files[0]?.name || '';
        } else {
            formData[fieldId] = field.value;
        }
        
        clearFieldError(fieldId);
        updateConditionalFields();
    }

    // Navigation
    function handlePrev() {
        if (currentStep > 0) {
            currentStep--;
            showStep(currentStep);
            updateNavigation();
            updateProgress();
        }
    }

    function handleNext() {
        if (validateCurrentStep()) {
            if (currentStep < config.totalSteps - 1) {
                currentStep++;
                showStep(currentStep);
                updateNavigation();
                updateProgress();
            } else {
                submitForm();
            }
        }
    }

    // Show step
    function showStep(index) {
        steps.forEach((step, i) => {
            step.classList.toggle('active', i === index);
        });
    }

    // Update navigation buttons
    function updateNavigation() {
        if (!prevBtn || !nextBtn) return;
        
        prevBtn.style.visibility = currentStep === 0 ? 'hidden' : 'visible';
        nextBtn.textContent = currentStep === config.totalSteps - 1 ? 'Submit' : 'Next ‚Üí';
    }

    // Update progress
    function updateProgress() {
        if (progressSteps.length === 0) return;
        
        progressSteps.forEach((step, i) => {
            step.classList.remove('active', 'completed');
            if (i === currentStep) step.classList.add('active');
            else if (i < currentStep) step.classList.add('completed');
        });

        if (progressConnectors) {
            progressConnectors.forEach((conn, i) => {
                conn.classList.toggle('completed', i < currentStep);
            });
        }

        if (progressText) {
            progressText.textContent = 'Step ' + (currentStep + 1) + ' of ' + config.totalSteps;
        }
    }

    // Validation
    function validateCurrentStep() {
        const currentStepEl = steps[currentStep];
        const fields = currentStepEl.querySelectorAll('[data-validate]');
        let isValid = true;

        fields.forEach(field => {
            if (field.closest('.form-field').classList.contains('hidden')) return;
            
            const fieldId = field.name;
            const fieldConfig = config.fields[fieldId];
            if (!fieldConfig) return;

            const result = validateField(field.value, fieldConfig);
            if (!result.valid) {
                showFieldError(fieldId, result.error);
                isValid = false;
            }
        });

        return isValid;
    }

    function validateField(value, rules) {
        // Required check
        if (rules.required && (!value || value.trim() === '')) {
            return { valid: false, error: 'This field is required' };
        }

        if (!value) return { valid: true };

        // Email validation
        if (rules.type === 'email') {
            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;
            if (!emailRegex.test(value)) {
                return { valid: false, error: 'Please enter a valid email' };
            }
        }

        // Mobile validation (10 digits)
        if (rules.type === 'mobile') {
            const mobileRegex = /^[0-9]{10}$/;
            if (!mobileRegex.test(value.replace(/\\D/g, ''))) {
                return { valid: false, error: 'Please enter a valid 10-digit mobile number' };
            }
        }

        // Min length
        if (rules.minLength && value.length < rules.minLength) {
            return { valid: false, error: 'Minimum ' + rules.minLength + ' characters required' };
        }

        // Max length
        if (rules.maxLength && value.length > rules.maxLength) {
            return { valid: false, error: 'Maximum ' + rules.maxLength + ' characters allowed' };
        }

        // Pattern
        if (rules.pattern) {
            try {
                const regex = new RegExp(rules.pattern);
                if (!regex.test(value)) {
                    return { valid: false, error: rules.errorMessage || 'Invalid format' };
                }
            } catch(e) {}
        }

        return { valid: true };
    }

    function showFieldError(fieldId, message) {
        const wrapper = document.querySelector('[data-field="' + fieldId + '"]');
        if (!wrapper) return;
        
        const input = wrapper.querySelector('input, select, textarea');
        const errorEl = wrapper.querySelector('.field-error');
        
        if (input) input.classList.add('error');
        if (errorEl) {
            errorEl.textContent = message;
            errorEl.classList.add('show');
        }
    }

    function clearFieldError(fieldId) {
        const wrapper = document.querySelector('[data-field="' + fieldId + '"]');
        if (!wrapper) return;
        
        const input = wrapper.querySelector('input, select, textarea');
        const errorEl = wrapper.querySelector('.field-error');
        
        if (input) input.classList.remove('error');
        if (errorEl) errorEl.classList.remove('show');
    }

    // Conditional Logic
    function initConditionalLogic() {
        updateConditionalFields();
    }

    function updateConditionalFields() {
        Object.entries(config.fields).forEach(([fieldId, fieldConfig]) => {
            if (fieldConfig.conditionalLogic && fieldConfig.conditionalLogic.enabled) {
                const wrapper = document.querySelector('[data-field="' + fieldId + '"]');
                if (!wrapper) return;

                const condition = fieldConfig.conditionalLogic;
                const isVisible = evaluateCondition(condition);
                
                wrapper.classList.toggle('hidden', !isVisible);
            }
        });
    }

    function evaluateCondition(condition) {
        const { field, operator, value } = condition;
        const fieldValue = formData[field] || '';

        switch (operator) {
            case 'equals': return fieldValue === value;
            case 'not_equals': return fieldValue !== value;
            case 'contains': return String(fieldValue).includes(value);
            case 'not_empty': return fieldValue !== '' && fieldValue !== null;
            case 'empty': return fieldValue === '' || fieldValue === null;
            default: return true;
        }
    }

    // Form Submission
    async function submitForm() {
        const submitBtn = nextBtn;
        submitBtn.disabled = true;
        submitBtn.textContent = 'Submitting...';

        // Collect all form data
        const formFields = form.querySelectorAll('input, select, textarea');
        formFields.forEach(field => {
            if (field.type === 'checkbox') {
                if (!formData[field.name]) formData[field.name] = [];
                if (field.checked && !formData[field.name].includes(field.value)) {
                    formData[field.name].push(field.value);
                }
            } else if (field.type !== 'file') {
                formData[field.name] = field.value;
            }
        });

        // Prepare payload
        const payload = {
            formData: formData,
            metadata: {
                timestamp: new Date().toISOString(),
                pageUrl: window.location.href,
                userAgent: navigator.userAgent,
                totalSteps: config.totalSteps
            }
        };

        // Send to webhook
        if (config.webhookUrl) {
            try {
                await fetch(config.webhookUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
            } catch (error) {
                console.error('Webhook error:', error);
            }
        }

        // Show success message
        form.style.display = 'none';
        successMessage.style.display = 'block';
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();`;
    },

    /**
     * Generate header HTML
     * @param {Object} header - Header configuration
     * @returns {string} Header HTML
     */
    generateHeaderHTML(header) {
        let html = '<header class="landing-header">\n';

        if (header.image?.url) {
            html += `            <img src="${Helpers.sanitizeHTML(header.image.url)}" alt="Header" class="header-image">\n`;
        }

        if (header.title?.text) {
            html += `            <h1 class="header-title">${Helpers.sanitizeHTML(header.title.text)}</h1>\n`;
        }

        if (header.description?.html) {
            html += `            <div class="header-description">${header.description.html}</div>\n`;
        }

        html += '        </header>';
        return html;
    },

    /**
     * Generate progress bar HTML
     * @param {Array} steps - Steps array
     * @returns {string} Progress bar HTML
     */
    generateProgressBar(steps) {
        let html = `            <div class="progress-container">
                <div class="progress-steps">\n`;

        steps.forEach((step, index) => {
            if (index > 0) {
                html += `                    <div class="progress-connector"></div>\n`;
            }
            html += `                    <div class="progress-step${index === 0 ? ' active' : ''}"></div>\n`;
        });

        html += `                </div>
                <div class="progress-text" id="progressText">Step 1 of ${steps.length}</div>
            </div>\n`;

        return html;
    },

    /**
     * Generate step HTML
     * @param {Object} step - Step configuration
     * @param {number} index - Step index
     * @param {number} total - Total steps
     * @returns {string} Step HTML
     */
    generateStepHTML(step, index, total) {
        let html = `                <div class="form-step${index === 0 ? ' active' : ''}" data-step="${index}">\n`;
        
        if (step.name) {
            html += `                    <h2 class="step-title">${Helpers.sanitizeHTML(step.name)}</h2>\n`;
        }

        step.fields.forEach(field => {
            html += this.generateFieldHTML(field);
        });

        html += '                </div>\n';
        return html;
    },

    /**
     * Generate field HTML
     * @param {Object} field - Field configuration
     * @returns {string} Field HTML
     */
    generateFieldHTML(field) {
        const { id, type, label, placeholder, required, options } = field;
        const requiredMark = required ? '<span class="required-mark">*</span>' : '';

        let html = `                    <div class="form-field" data-field="${id}">\n`;
        html += `                        <label class="field-label">${Helpers.sanitizeHTML(label)}${requiredMark}</label>\n`;

        switch (type) {
            case 'text':
            case 'email':
            case 'number':
            case 'date':
                const inputType = type === 'mobile' ? 'tel' : type;
                html += `                        <input type="${inputType}" name="${id}" class="field-input" placeholder="${Helpers.sanitizeHTML(placeholder || '')}" data-validate${required ? ' required' : ''}>\n`;
                break;

            case 'mobile':
                html += `                        <input type="tel" name="${id}" class="field-input" placeholder="${Helpers.sanitizeHTML(placeholder || 'Enter 10-digit mobile number')}" maxlength="10" pattern="[0-9]{10}" data-validate${required ? ' required' : ''}>\n`;
                break;

            case 'textarea':
                html += `                        <textarea name="${id}" class="field-textarea" placeholder="${Helpers.sanitizeHTML(placeholder || '')}" data-validate${required ? ' required' : ''}></textarea>\n`;
                break;

            case 'dropdown':
                html += `                        <select name="${id}" class="field-select" data-validate${required ? ' required' : ''}>
                            <option value="">${Helpers.sanitizeHTML(placeholder || 'Select an option')}</option>\n`;
                (options || []).forEach(opt => {
                    html += `                            <option value="${Helpers.sanitizeHTML(opt.value)}">${Helpers.sanitizeHTML(opt.label)}</option>\n`;
                });
                html += '                        </select>\n';
                break;

            case 'radio':
                html += '                        <div class="options-group">\n';
                (options || []).forEach(opt => {
                    html += `                            <label class="option-label">
                                <input type="radio" name="${id}" value="${Helpers.sanitizeHTML(opt.value)}" data-validate${required ? ' required' : ''}>
                                <span>${Helpers.sanitizeHTML(opt.label)}</span>
                            </label>\n`;
                });
                html += '                        </div>\n';
                break;

            case 'checkbox':
                html += '                        <div class="options-group">\n';
                (options || []).forEach(opt => {
                    html += `                            <label class="option-label">
                                <input type="checkbox" name="${id}" value="${Helpers.sanitizeHTML(opt.value)}">
                                <span>${Helpers.sanitizeHTML(opt.label)}</span>
                            </label>\n`;
                });
                html += '                        </div>\n';
                break;

            case 'file':
                html += `                        <div class="file-upload-wrapper" onclick="this.querySelector('input').click()">
                            <input type="file" name="${id}" data-validate${required ? ' required' : ''}>
                            <div class="file-upload-icon">üìé</div>
                            <div class="file-upload-text">Click to upload file</div>
                            <div class="file-name"></div>
                        </div>\n`;
                break;

            default:
                html += `                        <input type="text" name="${id}" class="field-input" placeholder="${Helpers.sanitizeHTML(placeholder || '')}" data-validate${required ? ' required' : ''}>\n`;
        }

        html += '                        <div class="field-error"></div>\n';
        html += '                    </div>\n';
        return html;
    },

    /**
     * Generate navigation HTML
     * @returns {string} Navigation HTML
     */
    generateNavigationHTML() {
        return `            <div class="form-navigation">
                <button type="button" id="prevBtn" class="btn btn-secondary" style="visibility: hidden;">‚Üê Previous</button>
                <button type="button" id="nextBtn" class="btn btn-primary">Next ‚Üí</button>
            </div>`;
    },

    /**
     * Generate fields configuration for validation
     * @param {Array} steps - Steps array
     * @returns {Object} Fields configuration
     */
    generateFieldsConfig(steps) {
        const fields = {};
        
        steps.forEach(step => {
            step.fields.forEach(field => {
                fields[field.id] = {
                    type: field.type,
                    required: field.required,
                    minLength: field.validation?.minLength,
                    maxLength: field.validation?.maxLength,
                    pattern: field.validation?.pattern,
                    errorMessage: field.validation?.errorMessage,
                    conditionalLogic: field.conditionalLogic
                };
            });
        });

        return fields;
    },

    /**
     * Generate JSON schema
     * @param {Object} state - Application state
     * @returns {Object} JSON schema
     */
    generateJSONSchema(state) {
        const { projectName, header, steps, settings } = state;

        return {
            schema_version: "1.0",
            project_name: projectName,
            created_at: new Date().toISOString(),
            header_image: header.image?.url || null,
            header_image_height: header.image?.height || 300,
            title: {
                text: header.title?.text || '',
                font_family: header.title?.fontFamily || 'Plus Jakarta Sans',
                font_size: header.title?.fontSize || 32,
                color: header.title?.color || '#1e293b',
                bold: header.title?.bold || false,
                italic: header.title?.italic || false,
                underline: header.title?.underline || false,
                align: header.title?.align || 'center'
            },
            description: {
                html: header.description?.html || '',
                text: header.description?.text || '',
                font_size: header.description?.fontSize || 16,
                color: header.description?.color || '#64748b'
            },
            steps: steps.map((step, index) => ({
                step_index: index,
                step_name: step.name || `Step ${index + 1}`,
                fields: step.fields.map(field => ({
                    id: field.id,
                    type: field.type,
                    label: field.label,
                    placeholder: field.placeholder || '',
                    required: field.required || false,
                    options: field.options || [],
                    validation: {
                        min_length: field.validation?.minLength || null,
                        max_length: field.validation?.maxLength || null,
                        pattern: field.validation?.pattern || null,
                        error_message: field.validation?.errorMessage || null,
                        mobile_10_digit: field.type === 'mobile',
                        email_format: field.type === 'email'
                    },
                    conditional_logic: field.conditionalLogic || {
                        enabled: false,
                        field: null,
                        operator: 'equals',
                        value: null
                    }
                }))
            })),
            settings: {
                show_progress_bar: settings.showProgressBar,
                submit_button_text: settings.submitButtonText || 'Submit',
                success_message: settings.successMessage || 'Thank you! Your response has been recorded.'
            },
            webhook_url: settings.webhookUrl || null
        };
    },

    /**
     * Create ZIP file with all assets
     * @param {Object} state - Application state
     * @returns {Promise<Blob>} ZIP blob
     */
    async createZIP(state) {
        // Simple ZIP creation without external library
        // In production, you'd use JSZip or similar
        const html = this.generateHTML(state);
        const json = JSON.stringify(this.generateJSONSchema(state), null, 2);
        
        // Return HTML file for now
        // For full ZIP support, integrate JSZip library
        return {
            html,
            css: this.generateCSS(state),
            js: this.generateJS(state),
            json
        };
    }
};

// Export for use in other modules
window.ExportUtils = ExportUtils;
